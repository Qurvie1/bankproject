TP Project 2024
Shataev Mikhail
Dugin Anton
Reviewer: Polina Podzorova
Б05-304

Проект: Банковская система
В чём смысл проекта? Делаем мини банки в каком-то произвольном абстрактном городе. Как и во всех банках, можно класть деньги на депозит, брать деньги в кредит, открыть дебетовой счёт, чтоб комфортно пользоваться своими деньгами (онлайн).
Собственно, должна поддержиться вся логика с этим связанная: съём денег, закидывание денег, переводы между клиентами в банке.
Пока что реализован только костяк, ещё много что хочется закинуть (как минимум хранение клиентов в каком-либо дереве или хэш-таблице по id, чтоб было удобно их находить и проводить с ними какие-либо операции).
В будущем возможны разнообразные дополнения: типа поддержка разных валют, разные проценты по депозитами, дополнительная защита операций и прочее.

Какие паттерны были реализованы:
1) Порождающий паттерн - Builder - реализован в моменте создания клиента. Есть интерфейс IBuilder и от него наследуется сам конструктор ClientBuilder (собственно, сам строитель клиента). 
В чём смысл его применения тут? Во-первых, реализуем создание объекта пошагово (то есть мы спокойно поддерживаем, что сначала вводится имя\фамилия, потом адрес (который можно кстати не вводить)) и так далее. Во-вторых, мы делаем удобнее читабельность кода (логично, что когда построение клиента зиждется на одном его конструкторе, то код становится не особо читабельным, потому что многое содержится и в самом клиенте, и в конструкторе 70 строк, и в самом клиенте ещё 70), в такой реализации мы выносим логику конструктора в отдельный объект - ClientBuilder (плюсом, в последствии можно делать разные виды клиента - как разные наследники от IBuilder (типа премиум клиент, клиент подешевле и прочее)), тогда это становится более понятным. Клиент - это клиент, ClientBuilder - его строит.

2) Порождающий паттерн - AbstractFactory - реализован в моменте создания счетов. Есть абстрактная фабрика AccountFactory, от которой отходит 3 фабрики-наследника - собственно, DepositAccountFactory, DebitAccountFactory и CreditAccountFactory.
При этом DepositAccount, DebitAccount и CreditAccount соответственно наследники Account (очевидно), отличаются лишь различиями между собой в плане функционала (кредиты, депозиты и дебет). Опять же - такая реализация, за счёт большого количества классов не захламляет код, а лишь делает его более читаемым (в силу того, что есть отдельные создатели счетов и мы видим, что счёт создаётся за их действие). Ну и обоснованность применения ещё и в том, что мы создаём примерно похожие объекты (счета), но немного отличающиеся семейства объектов.
Также, это позволяет дополнительно накинуть всякий функционал в будущем (в отличие, например, от обычной фабрики) - то есть сделать, например, депозитные счета для разной валюты (то есть 2D табличку счетов), всякие овердрафтные счета.

3) Поведенческий паттерн - Command - инкапсуляция транзакции как отдельного класса, а не просто действия. То есть у нас есть клиент (банк), Invoker (вызывающий - клиент), принимающий - тоже клиент, ну и транзакция - как операция. Опять же, удобство состоит в том, что мы выносим операцию в отдельный класс, за счёт чего удобнее отслеживать какие-либо транзакции. Ещё очень важный смысл для чего вообще всё это делается - это для удобства отмены транзакции. Поскольку у нас это реализуется в виде абстрактной структуры ICommand и наследника Transaction от этого всего, то мы можем просто пользуясь UndoTransaction - отменить её, при этом если реализовывать просто как метод, то это сделать уже труднее.

Как запускать? Пока толком нет какого-то сборщика, только если запускать отдельно cpp файлы, чтоб что-то проверять. В целом из реализованного полностью (но не факт, что рабочего, потому что много что взаимосвязано тут) - это создание клиента (то есть человек может вписать свои данные).

UML + Use-Case находится в src.

Кто что сделал?
Я - реализовал фабрику, комманд, написал ридмишку, юз-кейс диаграмму + ещё какие-то объявления с реализациями.
Антон - реализовал постройку клиента (Builder), UML + доделал остальные действия в проекте.

Ко второй итерации попробовали реализовать сам сервер, написанный на C++ (в теории, он должен располагаться на сервере), сайт, который работает через Flask (Python), сам код страницы, написанной на HTML.
Взаимодействие реализовано через сокеты - то есть сервер на плюсах принимает пакеты и что-то делает (в первичной версии реализовано, что он принимает регистрацию пользователя). Сам сервер на питоне принимает собственно отправку пользователем данных и перенаправляет в плюсовый код, через сокеты.
Было понять что происходит очень сложно, потому что нет опыта в том, что происходит.
В целом, тут ещё нужен косметический ремонт сайта (чтоб он нормально выглядел), разместить его на хостинге и сделать просто много функций - типа приём, отвод денег и так далее.    
Идейно в целом далее просто копипастой сделать кучу кода в HTML, связать с питоном и добавить отправку на плюсовый бэк.